<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>内存与垃圾回收</title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		/*
		 内存的声明周期
		1. 分配你所需要的内存
		2.使用分配到的内存（读、写）
		3.不需要时将其释放\归还
		垃圾回收
		垃圾回收算法主要依赖于引用（reference）的概念。在内存管理的环境中，
		一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。
		例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。
		在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。
		1.引用计数垃圾收集
		这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。
		如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
		 * */
		//实例
		var o = { 
  			a: {
    			b:2
  			}
		}; 
	// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
	// 很显然，没有一个可以被垃圾收集
	var o2 = o; // o2变量是第二个对“这个对象”的引用
		o = 1;      // 现在，“这个对象”的原始引用o被o2替换了

	var oa = o2.a; // 引用“这个对象”的a属性
		// 现在，“这个对象”有两个引用了，一个是o2，一个是oa

	o2 = "yo"; // 最初的对象现在已经是零引用了	
           // 他可以被垃圾回收了
           // 然而它的属性a的对象还在被oa引用，所以还不能回收

	oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
           
           /*
            	该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，
            	所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收
            * */
    function f(){
		  var o = {};
		  var o2 = {};
		  o.a = o2; // o 引用 o2
		  o2.a = o; // o2 引用 o
		
		  return "azerty";
	}
	f();
	
	//IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄露：
	var div;
	window.onload = function(){
		  div = document.getElementById("myDivElement");
		  div.circularReference = div;
		  div.lotsOfData = new Array(10000).join("*");
	};
	/*
	 	在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。
	 	如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。
	 	如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。
	 * */
	
	/*
	 标记-清除算法

	这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
	
	这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，
	找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。
	
	这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。
	
	从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，
	并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。
	
	循环引用不再是问题了
	
	在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。
	第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收

	 * */	
	</script>
</html>
