<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title></title>
</head>
<body>
</body>
<script src="https://unpkg.com/vue"></script>
<script type="text/javascript">
	/*
	假设你正在构建一个文件目录树，像在 Finder 或资源管理器中。你可能有一个 tree-folder 组件：
	<p>
	  <span>{{ folder.name }}</span>
	  <tree-folder-contents :children="folder.children"/>
	</p>
	及一个 tree-folder-contents 组件：
	<ul>
	  <li v-for="child in children">
		<tree-folder v-if="child.children" :folder="child"/>
		<span v-else>{{ child.name }}</span>
	  </li>
	</ul>
	当你仔细看时，会发现在渲染树上这两个组件同时为对方的父节点和子节点——这是矛盾的！
	当使用 Vue.component 将这两个组件注册为全局组件的时候，框架会自动为你解决这个矛盾。
	然而，如果你使用诸如 webpack 或者 Browserify 之类的模块化管理工具来 require/import 组件的话，就会报错了：
	
	    为了解释为什么会报错，简单的将上面两个组件称为 A 和 B。模块系统看到它需要 A，
	但是首先 A 需要 B，但是 B 需要 A，而 A 需要 B，循环往复。因为不知道到底应该先解析哪个，
	所以将会陷入无限循环。要解决这个问题，我们需要在其中一个组件中告诉模块化管理系统：“A 虽然最后会用到 B，
	但是不需要优先导入 B”。
	
	在我们的例子中，可以选择让 tree-folder 组件中来做这件事。我们知道引起矛盾的子组件是 tree-folder-contents，
	所以我们要等到 beforeCreate 生命周期钩子中才去注册它：
	
	//解决方法
	beforeCreate: function () {
	  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
	}
	
	*/
	
</script>
</html>
